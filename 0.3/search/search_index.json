{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Scruby-Full-Text","text":"<p> Full-text search with Manticore Search. <p> </p> </p> <p> Scruby-Full-Text is a plugin for the Scruby project. </p> <p></p> <p></p> <p></p> <p></p>"},{"location":"pages/installation/","title":"Installation","text":""},{"location":"pages/installation/#install-scruby-full-text","title":"Install Scruby-Full-Text","text":"<pre><code>uv add scruby-full-text\n</code></pre>"},{"location":"pages/installation/#install-manticore-search","title":"Install Manticore Search","text":"<p>For more information, see the documentation.</p>"},{"location":"pages/installation/#fedora-42-or-later","title":"Fedora 42 or later","text":"<pre><code># Install the repository:\nsudo tee /etc/yum.repos.d/manticore.repo &lt;&lt; \"EOF\" &gt; /dev/null\n[manticore]\nname=Manticore Repository\nbaseurl=http://repo.manticoresearch.com/repository/manticoresearch/release/centos/10/$basearch\ngpgcheck=1\nenabled=1\ngpgkey=https://repo.manticoresearch.com/GPG-KEY-SHA256-manticore\nEOF\n\n# Install Manticore Search:\nsudo dnf install manticore manticore-extra\n# Install English, German, and Russian lemmatizers:\nsudo dnf install manticore-language-packs\n\n# Run Manticore Search:\nsudo systemctl start manticore\nsudo systemctl enable manticore\nsudo systemctl status manticore --no-pager -l\n\n# HINT:\n# ------------------------------------------------------------------------------\n# Commands:\nsudo systemctl start manticore\nsudo systemctl restart manticore\nsudo systemctl stop manticore\nsudo systemctl enable manticore\nsudo systemctl is-enabled manticore\nsudo systemctl disable manticore\nsudo systemctl status manticore --no-pager -l\nsudo systemctl daemon-reload\nsudo journalctl -u manticore\n\n# Remove Manticore Search:\nsudo systemctl stop manticore\nsudo systemctl disable manticore\nsudo dnf erase $(rpm -qa | grep manticore)\nsudo rm -f /etc/yum.repos.d/manticore.repo\nsudo rm -r /var/log/manticore /var/lib/manticore /var/run/manticore\nsudo dnf makecache --refresh\n</code></pre>"},{"location":"pages/languages/","title":"Ianguages","text":""},{"location":"pages/languages/#supported-languages","title":"Supported languages","text":"<p>For more information, see the documentation.</p> Arabic ar Catalan ca Chinese zh Czech cz Danish da Dutch hl English en Finnish fi French fr German de Greek el Hindi hi Hungarian hu Indonesian id Irish ga Italian it Japanese ja Korean ko Lithuanian lt Nepali ne Norwegian no Portuguese pt Romanian ro Russian ru Spanish es Swedish sv Tamil ta Turkish tr"},{"location":"pages/plugin/","title":"Plugin","text":"<p>Plugin for full-text search.</p>"},{"location":"pages/plugin/#scruby_full_text.plugin.FullTextSearch","title":"<code>FullTextSearch</code>","text":"<p>               Bases: <code>ScrubyPlugin</code></p> <p>Plugin for Scruby based on Manticore Search.</p> Source code in <code>src/scruby_full_text/plugin.py</code> <pre><code>@final\nclass FullTextSearch(ScrubyPlugin):\n    \"\"\"Plugin for Scruby based on Manticore Search.\"\"\"\n\n    def __init__(self, scruby_self: Any) -&gt; None:  # noqa: D107\n        ScrubyPlugin.__init__(self, scruby_self)\n\n    @staticmethod\n    async def _task_find(\n        branch_number: int,\n        morphology: str,\n        full_text_filter: tuple[str, str],\n        filter_fn: Callable,\n        hash_reduce_left: str,\n        db_root: str,\n        class_model: Any,\n        config: manticoresearch.configuration.Configuration,\n    ) -&gt; list[Any] | None:\n        \"\"\"Task for finding documents, using full-text search.\n\n        This method is for internal use.\n\n        Returns:\n            List of documents or None.\n        \"\"\"\n        branch_number_as_hash: str = f\"{branch_number:08x}\"[hash_reduce_left:]\n        separated_hash: str = \"/\".join(list(branch_number_as_hash))\n        leaf_path = Path(\n            *(\n                db_root,\n                class_model.__name__,\n                separated_hash,\n                \"leaf.json\",\n            ),\n        )\n        docs: list[Any] = []\n        if await leaf_path.exists():\n            data_json: bytes = await leaf_path.read_bytes()\n            data: dict[str, str] = orjson.loads(data_json) or {}\n            table_name: str = \"scruby_\" + str(uuid.uuid4()).replace(\"-\", \"_\")[:8]\n            text_field_name: str = full_text_filter[0]\n            table_field: str = f\"{text_field_name} text\"\n            search_query = manticoresearch.SearchQuery(\n                query_string=f\"@{text_field_name} {full_text_filter[1]}\",\n            )\n            search_request = manticoresearch.SearchRequest(\n                table=table_name,\n                query=search_query,\n            )\n            # Enter a context with an instance of the API client\n            async with manticoresearch.ApiClient(config) as api_client:\n                # Create instances of API classes\n                index_api = manticoresearch.IndexApi(api_client)\n                search_api = manticoresearch.SearchApi(api_client)\n                utils_api = manticoresearch.UtilsApi(api_client)\n                # Create table\n                await utils_api.sql(f\"CREATE TABLE {table_name}({table_field}) morphology = '{morphology}'\")\n                # Start search\n                for _, val in data.items():\n                    doc = class_model.model_validate_json(val)\n                    if filter_fn(doc):\n                        text_field_content = getattr(doc, text_field_name)\n                        # Performs a search on a table\n                        insert_request = manticoresearch.InsertDocumentRequest(\n                            table=table_name,\n                            doc={text_field_name: text_field_content or \"\"},\n                        )\n                        await index_api.insert(insert_request)\n                        search_response = await search_api.search(search_request)\n                        if len(search_response.hits.hits) &gt; 0:\n                            docs.append(doc)\n                        # Clear table\n                        await utils_api.sql(f\"TRUNCATE TABLE {table_name}\")\n                # Delete table\n                await utils_api.sql(f\"DROP TABLE IF EXISTS {table_name}\")\n        return docs or None\n\n    async def find_one(\n        self,\n        morphology: str,\n        full_text_filter: tuple[str, str],\n        filter_fn: Callable = lambda _: True,\n    ) -&gt; Any | None:\n        \"\"\"Find a one document that matches the filter, using full-text search.\n\n        Attention:\n            - The search is based on the effect of a quantum loop.\n            - The search effectiveness depends on the number of processor threads.\n\n        Args:\n            morphology (str): String with morphology of language.\n            full_text_filter (tuple[str, str]): Filter for full-text search.\n                                                full_text_filter[0] -&gt; name of text field.\n                                                full_text_filter[1] -&gt; query string.\n            filter_fn (Callable): A function that execute the conditions of filtering.\n\n        Returns:\n            Document or None.\n        \"\"\"\n        # Get Scruby instance\n        scruby_self = self.scruby_self()\n        # Variable initialization\n        search_task_fn: Callable = self._task_find\n        branch_numbers: range = range(scruby_self._max_number_branch)\n        hash_reduce_left: int = scruby_self._hash_reduce_left\n        db_root: str = scruby_self._db_root\n        class_model: Any = scruby_self._class_model\n        config = FullTextSettings.config\n        # Run quantum loop\n        with concurrent.futures.ThreadPoolExecutor(scruby_self._max_workers) as executor:\n            for branch_number in branch_numbers:\n                future = executor.submit(\n                    search_task_fn,\n                    branch_number,\n                    morphology,\n                    full_text_filter,\n                    filter_fn,\n                    hash_reduce_left,\n                    db_root,\n                    class_model,\n                    config,\n                )\n                docs = await future.result()\n                if docs is not None:\n                    return docs[0]\n        return None\n\n    async def find_many(\n        self,\n        morphology: str,\n        full_text_filter: tuple[str, str],\n        filter_fn: Callable = lambda _: True,\n        limit_docs: int = 100,\n        page_number: int = 1,\n    ) -&gt; list[Any] | None:\n        \"\"\"Find the many of documents that match the filter, using full-text search.\n\n        Attention:\n            - The search is based on the effect of a quantum loop.\n            - The search effectiveness depends on the number of processor threads.\n\n        Args:\n            morphology (str): String with morphology of language.\n            full_text_filter (tuple[str, str]): Filter for full-text search.\n                                                full_text_filter[0] -&gt; name of text field.\n                                                full_text_filter[1] -&gt; text query.\n            filter_fn (Callable): A function that execute the conditions of filtering.\n                                  By default it searches for all documents.\n            limit_docs (int): Limiting the number of documents. By default = 100.\n            page_number (int): For pagination. By default = 1.\n                               Number of documents per page = limit_docs.\n\n        Returns:\n            List of documents or None.\n        \"\"\"\n        # The `page_number` parameter must not be less than one\n        assert page_number &gt; 0, \"`find_many` =&gt; The `page_number` parameter must not be less than one.\"\n        # Get Scruby instance\n        scruby_self = self.scruby_self()\n        # Variable initialization\n        search_task_fn: Callable = self._task_find\n        branch_numbers: range = range(scruby_self._max_number_branch)\n        hash_reduce_left: int = scruby_self._hash_reduce_left\n        db_root: str = scruby_self._db_root\n        class_model: Any = scruby_self._class_model\n        config = FullTextSettings.config\n        counter: int = 0\n        number_docs_skippe: int = limit_docs * (page_number - 1) if page_number &gt; 1 else 0\n        result: list[Any] = []\n        # Run quantum loop\n        with concurrent.futures.ThreadPoolExecutor(scruby_self._max_workers) as executor:\n            for branch_number in branch_numbers:\n                if number_docs_skippe == 0 and counter &gt;= limit_docs:\n                    return result[:limit_docs]\n                future = executor.submit(\n                    search_task_fn,\n                    branch_number,\n                    morphology,\n                    full_text_filter,\n                    filter_fn,\n                    hash_reduce_left,\n                    db_root,\n                    class_model,\n                    config,\n                )\n                docs = await future.result()\n                if docs is not None:\n                    for doc in docs:\n                        if number_docs_skippe == 0:\n                            if counter &gt;= limit_docs:\n                                return result[:limit_docs]\n                            result.append(doc)\n                            counter += 1\n                        else:\n                            number_docs_skippe -= 1\n        return result or None\n</code></pre>"},{"location":"pages/plugin/#scruby_full_text.plugin.FullTextSearch.find_many","title":"<code>find_many(morphology, full_text_filter, filter_fn=lambda _: True, limit_docs=100, page_number=1)</code>  <code>async</code>","text":"<p>Find the many of documents that match the filter, using full-text search.</p> Attention <ul> <li>The search is based on the effect of a quantum loop.</li> <li>The search effectiveness depends on the number of processor threads.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>morphology</code> <code>str</code> <p>String with morphology of language.</p> required <code>full_text_filter</code> <code>tuple[str, str]</code> <p>Filter for full-text search.                                 full_text_filter[0] -&gt; name of text field.                                 full_text_filter[1] -&gt; text query.</p> required <code>filter_fn</code> <code>Callable</code> <p>A function that execute the conditions of filtering.                   By default it searches for all documents.</p> <code>lambda _: True</code> <code>limit_docs</code> <code>int</code> <p>Limiting the number of documents. By default = 100.</p> <code>100</code> <code>page_number</code> <code>int</code> <p>For pagination. By default = 1.                Number of documents per page = limit_docs.</p> <code>1</code> <p>Returns:</p> Type Description <code>list[Any] | None</code> <p>List of documents or None.</p> Source code in <code>src/scruby_full_text/plugin.py</code> <pre><code>async def find_many(\n    self,\n    morphology: str,\n    full_text_filter: tuple[str, str],\n    filter_fn: Callable = lambda _: True,\n    limit_docs: int = 100,\n    page_number: int = 1,\n) -&gt; list[Any] | None:\n    \"\"\"Find the many of documents that match the filter, using full-text search.\n\n    Attention:\n        - The search is based on the effect of a quantum loop.\n        - The search effectiveness depends on the number of processor threads.\n\n    Args:\n        morphology (str): String with morphology of language.\n        full_text_filter (tuple[str, str]): Filter for full-text search.\n                                            full_text_filter[0] -&gt; name of text field.\n                                            full_text_filter[1] -&gt; text query.\n        filter_fn (Callable): A function that execute the conditions of filtering.\n                              By default it searches for all documents.\n        limit_docs (int): Limiting the number of documents. By default = 100.\n        page_number (int): For pagination. By default = 1.\n                           Number of documents per page = limit_docs.\n\n    Returns:\n        List of documents or None.\n    \"\"\"\n    # The `page_number` parameter must not be less than one\n    assert page_number &gt; 0, \"`find_many` =&gt; The `page_number` parameter must not be less than one.\"\n    # Get Scruby instance\n    scruby_self = self.scruby_self()\n    # Variable initialization\n    search_task_fn: Callable = self._task_find\n    branch_numbers: range = range(scruby_self._max_number_branch)\n    hash_reduce_left: int = scruby_self._hash_reduce_left\n    db_root: str = scruby_self._db_root\n    class_model: Any = scruby_self._class_model\n    config = FullTextSettings.config\n    counter: int = 0\n    number_docs_skippe: int = limit_docs * (page_number - 1) if page_number &gt; 1 else 0\n    result: list[Any] = []\n    # Run quantum loop\n    with concurrent.futures.ThreadPoolExecutor(scruby_self._max_workers) as executor:\n        for branch_number in branch_numbers:\n            if number_docs_skippe == 0 and counter &gt;= limit_docs:\n                return result[:limit_docs]\n            future = executor.submit(\n                search_task_fn,\n                branch_number,\n                morphology,\n                full_text_filter,\n                filter_fn,\n                hash_reduce_left,\n                db_root,\n                class_model,\n                config,\n            )\n            docs = await future.result()\n            if docs is not None:\n                for doc in docs:\n                    if number_docs_skippe == 0:\n                        if counter &gt;= limit_docs:\n                            return result[:limit_docs]\n                        result.append(doc)\n                        counter += 1\n                    else:\n                        number_docs_skippe -= 1\n    return result or None\n</code></pre>"},{"location":"pages/plugin/#scruby_full_text.plugin.FullTextSearch.find_one","title":"<code>find_one(morphology, full_text_filter, filter_fn=lambda _: True)</code>  <code>async</code>","text":"<p>Find a one document that matches the filter, using full-text search.</p> Attention <ul> <li>The search is based on the effect of a quantum loop.</li> <li>The search effectiveness depends on the number of processor threads.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>morphology</code> <code>str</code> <p>String with morphology of language.</p> required <code>full_text_filter</code> <code>tuple[str, str]</code> <p>Filter for full-text search.                                 full_text_filter[0] -&gt; name of text field.                                 full_text_filter[1] -&gt; query string.</p> required <code>filter_fn</code> <code>Callable</code> <p>A function that execute the conditions of filtering.</p> <code>lambda _: True</code> <p>Returns:</p> Type Description <code>Any | None</code> <p>Document or None.</p> Source code in <code>src/scruby_full_text/plugin.py</code> <pre><code>async def find_one(\n    self,\n    morphology: str,\n    full_text_filter: tuple[str, str],\n    filter_fn: Callable = lambda _: True,\n) -&gt; Any | None:\n    \"\"\"Find a one document that matches the filter, using full-text search.\n\n    Attention:\n        - The search is based on the effect of a quantum loop.\n        - The search effectiveness depends on the number of processor threads.\n\n    Args:\n        morphology (str): String with morphology of language.\n        full_text_filter (tuple[str, str]): Filter for full-text search.\n                                            full_text_filter[0] -&gt; name of text field.\n                                            full_text_filter[1] -&gt; query string.\n        filter_fn (Callable): A function that execute the conditions of filtering.\n\n    Returns:\n        Document or None.\n    \"\"\"\n    # Get Scruby instance\n    scruby_self = self.scruby_self()\n    # Variable initialization\n    search_task_fn: Callable = self._task_find\n    branch_numbers: range = range(scruby_self._max_number_branch)\n    hash_reduce_left: int = scruby_self._hash_reduce_left\n    db_root: str = scruby_self._db_root\n    class_model: Any = scruby_self._class_model\n    config = FullTextSettings.config\n    # Run quantum loop\n    with concurrent.futures.ThreadPoolExecutor(scruby_self._max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                search_task_fn,\n                branch_number,\n                morphology,\n                full_text_filter,\n                filter_fn,\n                hash_reduce_left,\n                db_root,\n                class_model,\n                config,\n            )\n            docs = await future.result()\n            if docs is not None:\n                return docs[0]\n    return None\n</code></pre>"},{"location":"pages/settings/","title":"Settings","text":"<p>Plugin settings.</p> <p>The settings class contains the following parameters:</p> <ul> <li><code>config</code> - Configuration options for https://github.com/manticoresoftware/manticoresearch-python-asyncio.</li> <li><code>languages</code> - List of supported languages and full-text search algorithms.</li> </ul>"},{"location":"pages/settings/#scruby_full_text.settings.FullTextSettings","title":"<code>FullTextSettings</code>","text":"<p>Plugin settings.</p> Source code in <code>src/scruby_full_text/settings.py</code> <pre><code>@final\nclass FullTextSettings:\n    \"\"\"Plugin settings.\"\"\"\n\n    config: ClassVar[Configuration] = Configuration(host=\"http://127.0.0.1:9312\")\n\n    # List of supported languages for full-text search.\n    morphology: ClassVar[AliasDict] = AliasDict(\n        [\n            ({\"Arabic\", \"ar\"}, \"libstemmer_ar\"),\n            ({\"Catalan\", \"ca\"}, \"libstemmer_ca\"),\n            ({\"Chinese\", \"zh\"}, \"jieba_chinese\"),\n            ({\"Czech\", \"cz\"}, \"stem_cz\"),\n            ({\"Danish\", \"da\"}, \"libstemmer_da\"),\n            ({\"Dutch\", \"hl\"}, \"libstemmer_nl\"),\n            ({\"English\", \"en\"}, \"lemmatize_en_all\"),\n            ({\"Finnish\", \"fi\"}, \"libstemmer_fi\"),\n            ({\"French\", \"fr\"}, \"libstemmer_fr\"),\n            ({\"German\", \"de\"}, \"lemmatize_de_all\"),\n            ({\"Greek\", \"el\"}, \"libstemmer_el\"),\n            ({\"Hindi\", \"hi\"}, \"libstemmer_hi\"),\n            ({\"Hungarian\", \"hu\"}, \"libstemmer_hu\"),\n            ({\"Indonesian\", \"id\"}, \"libstemmer_id\"),\n            ({\"Irish\", \"ga\"}, \"libstemmer_ga\"),\n            ({\"Italian\", \"it\"}, \"libstemmer_it\"),\n            ({\"Japanese\", \"ja\"}, \"ngram_chars=japanese ngram_len=1\"),\n            ({\"Korean\", \"ko\"}, \"ngram_chars=korean ngram_len=1\"),\n            ({\"Lithuanian\", \"lt\"}, \"libstemmer_lt\"),\n            ({\"Nepali\", \"ne\"}, \"libstemmer_ne\"),\n            ({\"Norwegian\", \"no\"}, \"libstemmer_no\"),\n            ({\"Portuguese\", \"pt\"}, \"libstemmer_pt\"),\n            ({\"Romanian\", \"ro\"}, \"libstemmer_ro\"),\n            ({\"Russian\", \"ru\"}, \"lemmatize_ru_all\"),\n            ({\"Spanish\", \"es\"}, \"libstemmer_es\"),\n            ({\"Swedish\", \"sv\"}, \"libstemmer_sv\"),\n            ({\"Tamil\", \"ta\"}, \"libstemmer_ta\"),\n            ({\"Turkish\", \"tr\"}, \"libstemmer_tr\"),\n        ],\n    )\n</code></pre>"},{"location":"pages/usage/","title":"Usage","text":""},{"location":"pages/usage/#example-of-using-the-plugin","title":"Example of using the plugin","text":"main.py<pre><code>import anyio\nfrom typing import Any\nfrom pydantic import Field\nfrom scruby import Scruby, ScrubyModel, ScrubySettings\nfrom scruby_full_text import FullTextSearch, FullTextSettings\nfrom pprint import pprint as pp\n\n# Plugins connection.\nScrubySettings.plugins = [\n    FullTextSearch,\n]\n\n\nclass Car(ScrubyModel):\n    brand: str = Field(strict=True, frozen=True)\n    model: str = Field(strict=True, frozen=True)\n    year: int = Field(strict=True, frozen=True)\n    power_reserve: int = Field(strict=True, frozen=True)\n    description: str = Field(strict=True)\n    # key is always at bottom\n    key: str = Field(\n        strict=True,\n        frozen=True,\n        default_factory=lambda data: f\"{data['brand']}:{data['model']}\",\n    )\n\n\ndef main() -&gt; None:\n    # Get collection `Car`\n    car_coll = await Scruby.collection(Car)\n    # Create cars.\n    for num in range(1, 10):\n        car = Car(\n            brand=\"Mazda\",\n            model=f\"EZ-6 {num}\",\n            year=2025,\n            power_reserve=600,\n            description=\"Electric cars are the future of the global automotive industry.\",\n        )\n        await car_coll.add_doc(car)\n\n    # Find one car\n    car = await car_coll.plugins.fullTextSearch.find_one(\n        morphology=FullTextSettings.morphology.get(\"English\"),  # 'English' or 'en'\n        full_text_filter=(\"model\", \"EZ-6 9\"),\n        # filter_fn=lambda doc: doc.brand == \"Mazda\",\n    )\n    if car is not None:\n      pp(car)\n    else:\n      print(\"Not Found\")\n\n    # Fand many cars\n    car_list = await car_coll.plugins.fullTextSearch.find_many(\n        morphology=FullTextSettings.morphology.get(\"en\"),  # 'en' or 'English'\n        full_text_filter=(\"description\", \"future of automotive\"),\n        # filter_fn=lambda doc: doc.brand == \"Mazda\",\n    )\n    if car_list is not None:\n      pp(car_list)\n    else:\n      print(\"Not Found\")\n\n    # Full database deletion.\n    # Hint: The main purpose is tests.\n    Scruby.napalm()\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"}]}