{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Scruby-Full-Text","text":"<p> Title... <p> </p> </p> <p> DESCRIPTION... </p>"},{"location":"#requirements","title":"Requirements","text":"<p>View the list of requirements.</p>"},{"location":"#changelog","title":"Changelog","text":"<p>View the change history.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT.</p>"},{"location":"pages/details/","title":"Details","text":"<p>Scruby-Full-Text - Full-text search with Manticore Search.</p>"},{"location":"pages/details/#scruby_full_text.FullText","title":"<code>FullText</code>","text":"<p>Plugin for Scruby based on Manticore Search.</p> Source code in <code>src/scruby_full_text/plugin.py</code> <pre><code>class FullText:\n    \"\"\"Plugin for Scruby based on Manticore Search.\"\"\"\n\n    def __init__(self, scruby: Any) -&gt; None:  # noqa: D107\n        self.scruby = weakref.ref(scruby)\n\n    @staticmethod\n    async def _task_find(\n        branch_number: int,\n        full_text_filter: dict[str, str],  # noqa: ARG004\n        filter_fn: Callable,\n        hash_reduce_left: str,\n        db_root: str,\n        class_model: Any,\n    ) -&gt; list[Any] | None:\n        \"\"\"Task for finding documents, using full-text search.\n\n        This method is for internal use.\n\n        Returns:\n            List of documents or None.\n        \"\"\"\n        branch_number_as_hash: str = f\"{branch_number:08x}\"[hash_reduce_left:]\n        separated_hash: str = \"/\".join(list(branch_number_as_hash))\n        leaf_path: Path = Path(\n            *(\n                db_root,\n                class_model.__name__,\n                separated_hash,\n                \"leaf.json\",\n            ),\n        )\n        docs: list[Any] = []\n        if await leaf_path.exists():\n            data_json: bytes = await leaf_path.read_bytes()\n            data: dict[str, str] = orjson.loads(data_json) or {}\n            for _, val in data.items():\n                doc = class_model.model_validate_json(val)\n                if filter_fn(doc):\n                    docs.append(doc)\n        return docs or None\n\n    async def find_one(\n        self,\n        full_text_filter: dict[str, str],\n        filter_fn: Callable = lambda _: True,\n    ) -&gt; Any | None:\n        \"\"\"Find a one document that matches the filter, using full-text search.\n\n        Attention:\n            - The search is based on the effect of a quantum loop.\n            - The search effectiveness depends on the number of processor threads.\n\n        Args:\n            full_text_filter (dict[str, str]): Filter for full-text search.\n                                               Key -&gt; name of text field.\n                                               Value -&gt; text query.\n            filter_fn (Callable): A function that execute the conditions of filtering.\n\n        Returns:\n            Document or None.\n        \"\"\"\n        # Variable initialization\n        scruby = self.scruby()\n        search_task_fn: Callable = self._task_find\n        branch_numbers: range = range(scruby._max_number_branch)\n        hash_reduce_left: int = scruby._hash_reduce_left\n        db_root: str = scruby._db_root\n        class_model: Any = scruby._class_model\n        # Run quantum loop\n        with concurrent.futures.ThreadPoolExecutor(scruby._max_workers) as executor:\n            for branch_number in branch_numbers:\n                future = executor.submit(\n                    search_task_fn,\n                    branch_number,\n                    full_text_filter,\n                    filter_fn,\n                    hash_reduce_left,\n                    db_root,\n                    class_model,\n                )\n                docs = await future.result()\n                if docs is not None:\n                    return docs[0]\n        return None\n\n    async def find_many(\n        self,\n        full_text_filter: dict[str, str],\n        filter_fn: Callable = lambda _: True,\n        limit_docs: int = 100,\n        page_number: int = 1,\n    ) -&gt; list[Any] | None:\n        \"\"\"Find the many of documents that match the filter, using full-text search.\n\n        Attention:\n            - The search is based on the effect of a quantum loop.\n            - The search effectiveness depends on the number of processor threads.\n\n        Args:\n            full_text_filter (dict[str, str]): Filter for full-text search.\n                                               Key -&gt; name of text field.\n                                               Value -&gt; text query.\n            filter_fn (Callable): A function that execute the conditions of filtering.\n                                  By default it searches for all documents.\n            limit_docs (int): Limiting the number of documents. By default = 100.\n            page_number (int): For pagination. By default = 1.\n                               Number of documents per page = limit_docs.\n\n        Returns:\n            List of documents or None.\n        \"\"\"\n        # The `page_number` parameter must not be less than one\n        assert page_number &gt; 0, \"`find_many` =&gt; The `page_number` parameter must not be less than one.\"\n        # Variable initialization\n        scruby = self.scruby()\n        search_task_fn: Callable = self._task_find\n        branch_numbers: range = range(scruby._max_number_branch)\n        hash_reduce_left: int = scruby._hash_reduce_left\n        db_root: str = scruby._db_root\n        class_model: Any = scruby._class_model\n        counter: int = 0\n        number_docs_skippe: int = limit_docs * (page_number - 1) if page_number &gt; 1 else 0\n        result: list[Any] = []\n        # Run quantum loop\n        with concurrent.futures.ThreadPoolExecutor(scruby._max_workers) as executor:\n            for branch_number in branch_numbers:\n                if number_docs_skippe == 0 and counter &gt;= limit_docs:\n                    return result[:limit_docs]\n                future = executor.submit(\n                    search_task_fn,\n                    branch_number,\n                    full_text_filter,\n                    filter_fn,\n                    hash_reduce_left,\n                    db_root,\n                    class_model,\n                )\n                docs = await future.result()\n                if docs is not None:\n                    for doc in docs:\n                        if number_docs_skippe == 0:\n                            if counter &gt;= limit_docs:\n                                return result[:limit_docs]\n                            result.append(doc)\n                            counter += 1\n                        else:\n                            number_docs_skippe -= 1\n        return result or None\n</code></pre>"},{"location":"pages/details/#scruby_full_text.FullText.find_many","title":"<code>find_many(full_text_filter, filter_fn=lambda _: True, limit_docs=100, page_number=1)</code>  <code>async</code>","text":"<p>Find the many of documents that match the filter, using full-text search.</p> Attention <ul> <li>The search is based on the effect of a quantum loop.</li> <li>The search effectiveness depends on the number of processor threads.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>full_text_filter</code> <code>dict[str, str]</code> <p>Filter for full-text search.                                Key -&gt; name of text field.                                Value -&gt; text query.</p> required <code>filter_fn</code> <code>Callable</code> <p>A function that execute the conditions of filtering.                   By default it searches for all documents.</p> <code>lambda _: True</code> <code>limit_docs</code> <code>int</code> <p>Limiting the number of documents. By default = 100.</p> <code>100</code> <code>page_number</code> <code>int</code> <p>For pagination. By default = 1.                Number of documents per page = limit_docs.</p> <code>1</code> <p>Returns:</p> Type Description <code>list[Any] | None</code> <p>List of documents or None.</p> Source code in <code>src/scruby_full_text/plugin.py</code> <pre><code>async def find_many(\n    self,\n    full_text_filter: dict[str, str],\n    filter_fn: Callable = lambda _: True,\n    limit_docs: int = 100,\n    page_number: int = 1,\n) -&gt; list[Any] | None:\n    \"\"\"Find the many of documents that match the filter, using full-text search.\n\n    Attention:\n        - The search is based on the effect of a quantum loop.\n        - The search effectiveness depends on the number of processor threads.\n\n    Args:\n        full_text_filter (dict[str, str]): Filter for full-text search.\n                                           Key -&gt; name of text field.\n                                           Value -&gt; text query.\n        filter_fn (Callable): A function that execute the conditions of filtering.\n                              By default it searches for all documents.\n        limit_docs (int): Limiting the number of documents. By default = 100.\n        page_number (int): For pagination. By default = 1.\n                           Number of documents per page = limit_docs.\n\n    Returns:\n        List of documents or None.\n    \"\"\"\n    # The `page_number` parameter must not be less than one\n    assert page_number &gt; 0, \"`find_many` =&gt; The `page_number` parameter must not be less than one.\"\n    # Variable initialization\n    scruby = self.scruby()\n    search_task_fn: Callable = self._task_find\n    branch_numbers: range = range(scruby._max_number_branch)\n    hash_reduce_left: int = scruby._hash_reduce_left\n    db_root: str = scruby._db_root\n    class_model: Any = scruby._class_model\n    counter: int = 0\n    number_docs_skippe: int = limit_docs * (page_number - 1) if page_number &gt; 1 else 0\n    result: list[Any] = []\n    # Run quantum loop\n    with concurrent.futures.ThreadPoolExecutor(scruby._max_workers) as executor:\n        for branch_number in branch_numbers:\n            if number_docs_skippe == 0 and counter &gt;= limit_docs:\n                return result[:limit_docs]\n            future = executor.submit(\n                search_task_fn,\n                branch_number,\n                full_text_filter,\n                filter_fn,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            docs = await future.result()\n            if docs is not None:\n                for doc in docs:\n                    if number_docs_skippe == 0:\n                        if counter &gt;= limit_docs:\n                            return result[:limit_docs]\n                        result.append(doc)\n                        counter += 1\n                    else:\n                        number_docs_skippe -= 1\n    return result or None\n</code></pre>"},{"location":"pages/details/#scruby_full_text.FullText.find_one","title":"<code>find_one(full_text_filter, filter_fn=lambda _: True)</code>  <code>async</code>","text":"<p>Find a one document that matches the filter, using full-text search.</p> Attention <ul> <li>The search is based on the effect of a quantum loop.</li> <li>The search effectiveness depends on the number of processor threads.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>full_text_filter</code> <code>dict[str, str]</code> <p>Filter for full-text search.                                Key -&gt; name of text field.                                Value -&gt; text query.</p> required <code>filter_fn</code> <code>Callable</code> <p>A function that execute the conditions of filtering.</p> <code>lambda _: True</code> <p>Returns:</p> Type Description <code>Any | None</code> <p>Document or None.</p> Source code in <code>src/scruby_full_text/plugin.py</code> <pre><code>async def find_one(\n    self,\n    full_text_filter: dict[str, str],\n    filter_fn: Callable = lambda _: True,\n) -&gt; Any | None:\n    \"\"\"Find a one document that matches the filter, using full-text search.\n\n    Attention:\n        - The search is based on the effect of a quantum loop.\n        - The search effectiveness depends on the number of processor threads.\n\n    Args:\n        full_text_filter (dict[str, str]): Filter for full-text search.\n                                           Key -&gt; name of text field.\n                                           Value -&gt; text query.\n        filter_fn (Callable): A function that execute the conditions of filtering.\n\n    Returns:\n        Document or None.\n    \"\"\"\n    # Variable initialization\n    scruby = self.scruby()\n    search_task_fn: Callable = self._task_find\n    branch_numbers: range = range(scruby._max_number_branch)\n    hash_reduce_left: int = scruby._hash_reduce_left\n    db_root: str = scruby._db_root\n    class_model: Any = scruby._class_model\n    # Run quantum loop\n    with concurrent.futures.ThreadPoolExecutor(scruby._max_workers) as executor:\n        for branch_number in branch_numbers:\n            future = executor.submit(\n                search_task_fn,\n                branch_number,\n                full_text_filter,\n                filter_fn,\n                hash_reduce_left,\n                db_root,\n                class_model,\n            )\n            docs = await future.result()\n            if docs is not None:\n                return docs[0]\n    return None\n</code></pre>"},{"location":"pages/installation/","title":"Installation","text":"<pre><code>uv add scruby-full-text\n</code></pre>"},{"location":"pages/usage/","title":"Usage","text":"main.py<pre><code>import scruby_full_text\n</code></pre>"}]}